__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1609289266214, "server": [".py", "from flask import Flask,render_template\napp=Flask(__name__)\n\n@app.route('/')\ndef index():\n return render_template('Home.html')\n \n@app.route('/speed.html')\ndef my_link():\n print('I got clicked 811213')\n \n return 'Click.'\nif __name__ =='__main__':\n app.run(debug=True )\n", ["flask"]], "Speed Detection": [".py", "import cv2\nimport numpy as np\nimport time\nimport matplotlib.pyplot as plt\nimport math\n\n\ncap=cv2.VideoCapture(0)\nstartx=-1\n\ndef capture():\n print(\"Speed Detector ON\")\n global startx\n startx=-1\n \n _,prevc=cap.read()\n prevc=cv2.flip(prevc,1)\n \n while True :\n  _,newc=cap.read()\n  newc=cv2.flip(newc,1)\n  diffc=cv2.absdiff(prevc,newc)\n  diffc=cv2.cvtColor(diffc,cv2.COLOR_BGR2GRAY)\n  diffc=cv2.blur(diffc,(4,4))\n  _,diffc=cv2.threshold(diffc,10,255,cv2.THRESH_BINARY)\n  contorc=cv2.findContours(diffc,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)[0]\n  \n  for contc in contorc:\n   if cv2.contourArea(contc)>3000:\n    (x1c,y1c),rad=cv2.minEnclosingCircle(contc)\n    if x1c <545 and x1c >105:\n     startx=x1c\n     \n  prevc=newc.copy()\n  \n  \n  \n  \n  if cv2.waitKey(1)==27 or startx !=-1:\n  \n   break\n   \n return startx\n \n \ndef right():\n print(\"from right\")\n endxr=-1\n global startx\n start_time=time.time()\n _,prevr=cap.read()\n prevr=cv2.flip(prevr,1)\n while True :\n  _,newr=cap.read()\n  newr=cv2.flip(newr,1)\n  diffr=cv2.absdiff(prevr,newr)\n  diffr=cv2.cvtColor(diffr,cv2.COLOR_BGR2GRAY)\n  diffr=cv2.blur(diffr,(4,4))\n  _,diffr=cv2.threshold(diffr,10,255,cv2.THRESH_BINARY)\n  contorr=cv2.findContours(diffr,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)[0]\n  for contr in contorr:\n   if cv2.contourArea(contr)>30000:\n    (x,y,w,h)=cv2.boundingRect(contr)\n    (x1r,y1r),rad=cv2.minEnclosingCircle(contr)\n    cv2.rectangle(prevr,(x,y),(x+w,y+h),(0,255,0),2)\n    if x1r >550:\n     endxr=x1r\n     end_time=time.time()\n     print(\"it took {}\".format(end_time -start_time))\n     print(\"Speed detected = {} px/sec\".format(math.trunc(np.sqrt((550 -startx)**2)/(end_time -start_time))))\n     cv2.putText(prevr,\"speed:{} px/sec\".format(math.trunc(np.sqrt((550 -startx)**2)/(end_time -start_time))),(50,100),cv2.FONT_HERSHEY_SIMPLEX,1,(0,255,0),3)\n     break\n     \n  cv2.imshow(\"right\",prevr)\n  prevr=newr.copy()\n  \n  if endxr >550 or cv2.waitKey(1)==27:\n  \n   break\n return None\n \ndef left():\n global startx\n endx=700\n print(\"from left\")\n start_time=time.time()\n _,prev=cap.read()\n prev=cv2.flip(prev,1)\n while True :\n  _,new=cap.read()\n  new=cv2.flip(new,1)\n  diff=cv2.absdiff(prev,new)\n  diff=cv2.cvtColor(diff,cv2.COLOR_BGR2GRAY)\n  diff=cv2.blur(diff,(4,4))\n  _,diff=cv2.threshold(diff,10,255,cv2.THRESH_BINARY)\n  contor=cv2.findContours(diff,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)[0]\n  for cont in contor:\n   if cv2.contourArea(cont)>30000:\n   \n    (x,y,w,h)=cv2.boundingRect(cont)\n    (x1,y1),rad=cv2.minEnclosingCircle(cont)\n    cv2.rectangle(prev,(x,y),(x+w,y+h),(0,255,0),2)\n    if x1 <100:\n     endx=x1\n     end_time=time.time()\n     print(\"it took {}\".format(end_time -start_time))\n     print(\"Speed detected = {} px/sec\".format(math.trunc(np.sqrt((startx -x1)**2)/(end_time -start_time))))\n     cv2.putText(prev,\"speed:{} px/sec\".format(math.trunc(np.sqrt((startx -x1)**2)/(end_time -start_time))),(50,100),cv2.FONT_HERSHEY_SIMPLEX,1,(0,255,0),3)\n     \n     break\n     \n  cv2.imshow(\"left\",prev)\n  prev=new.copy()\n  \n  if endx <100 or cv2.waitKey(1)==27:\n   break\n return None\n \n \n \nwhile True :\n if capture()<150:\n  right()\n  \n elif cv2.waitKey(1)==27:\n  break\n else :\n  left()\n  \n  \n if cv2.waitKey(1)==27:\n  break\n  \ncap.release()\ncv2.destroyAllWindows()\n", ["cv2", "math", "matplotlib.pyplot", "numpy", "time"]], "brython.list_modules": [".py", "''\n\n\n\n\n\n\nimport os\nimport shutil\nimport html.parser\nimport json\nimport traceback\nimport sys\nimport time\nimport io\nimport tokenize\nimport token\n\n\nsetup=\"\"\"from setuptools import setup, find_packages\n\nimport os\n\nif os.path.exists('README.rst'):\n    with open('README.rst', encoding='utf-8') as fobj:\n        LONG_DESCRIPTION = fobj.read()\n\nsetup(\n    name='{app_name}',\n    version='{version}',\n\n    # The project's main homepage.\n    url='{url}',\n\n    # Author details\n    author='{author}',\n    author_email='{author_email}',\n\n    # License\n    license='{license}',\n\n    packages=['data'],\n    py_modules=[\"{app_name}\"],\n    package_data={{'data':[{files}]}}\n)\n\"\"\"\n\n\napp=\"\"\"import os\nimport shutil\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('--install',\n    help='Install {app_name} in an empty directory',\n    action=\"store_true\")\nargs = parser.parse_args()\n\nfiles = ({files})\n\nif args.install:\n    print('Installing {app_name} in an empty directory')\n\n    src_path = os.path.join(os.path.dirname(__file__), 'data')\n\n    if os.listdir(os.getcwd()):\n        print('{app_name} can only be installed in an empty folder')\n        import sys\n        sys.exit()\n\n    for path in files:\n        dst = os.path.join(os.getcwd(), path)\n        head, tail = os.path.split(dst)\n        if not os.path.exists(head):\n            os.mkdir(head)\n        shutil.copyfile(os.path.join(src_path, path), dst)\n\n\"\"\"\n\n\nclass FromImport:\n\n def __init__(self):\n  self.source=''\n  self.type=\"from\"\n  self.level=0\n  self.expect=\"source\"\n  self.names=[]\n  \n def __str__(self):\n  return '<import '+str(self.names)+' from '+str(self.source)+'>'\n  \n  \nclass Import:\n\n def __init__(self):\n  self.type=\"import\"\n  self.expect=\"module\"\n  self.modules=[]\n  \n def __str__(self):\n  return '<import '+str(self.modules)+'>'\n  \n  \nclass ImportsFinder:\n\n def __init__(self,*args,**kw):\n  self.package=kw.pop(\"package\")or \"\"\n  \n def find(self,src):\n  ''\n\n  \n  imports=set()\n  importing=None\n  f=io.BytesIO(src.encode(\"utf-8\"))\n  for tok_type,tok_string,*_ in tokenize.tokenize(f.readline):\n   tok_type=token.tok_name[tok_type]\n   if importing is None :\n    if tok_type ==\"NAME\"and tok_string in [\"import\",\"from\"]:\n     context=Import()if tok_string ==\"import\"\\\n     else FromImport()\n     importing=True\n   else :\n    if tok_type ==\"NEWLINE\":\n     imports.add(context)\n     importing=None\n    else :\n     self.transition(context,tok_type,tok_string)\n     \n  if importing:\n   imports.add(context)\n   \n   \n  self.imports=set()\n  for imp in imports:\n   if isinstance(imp,Import):\n    for mod in imp.modules:\n     parts=mod.split('.')\n     while parts:\n      self.imports.add('.'.join(parts))\n      parts.pop()\n   elif isinstance(imp,FromImport):\n    source=imp.source\n    if imp.level >0:\n     if imp.level ==1:\n      imp.source=self.package\n     else :\n      parts=self.package.split(\".\")\n      imp.source='.'.join(parts[:1 -imp.level])\n     if source:\n      imp.source +='.'+source\n    parts=imp.source.split('.')\n    while parts:\n     self.imports.add('.'.join(parts))\n     parts.pop()\n    self.imports.add(imp.source)\n    for name in imp.names:\n     parts=name.split('.')\n     while parts:\n      self.imports.add(imp.source+'.'+'.'.join(parts))\n      parts.pop()\n      \n def transition(self,context,token,value):\n  if context.type ==\"from\":\n   if token ==\"NAME\":\n    if context.expect ==\"source\":\n     if value ==\"import\"and context.level:\n     \n      context.expect=\"names\"\n     else :\n      context.source +=value\n      context.expect=\".\"\n    elif context.expect ==\".\"and value ==\"import\":\n     context.expect=\"names\"\n    elif context.expect ==\"names\":\n     context.names.append(value)\n     context.expect=\",\"\n   elif token ==\"OP\":\n    if value ==\",\"and context.expect ==\",\":\n     context.expect=\"names\"\n    elif value ==\".\"and context.expect ==\".\":\n     context.source +='.'\n     context.expect=\"source\"\n    elif value ==\".\"and context.expect ==\"source\":\n     context.level +=1\n     \n  elif context.type ==\"import\":\n   if token ==\"NAME\":\n    if context.expect ==\"module\":\n     if context.modules and context.modules[-1].endswith(\".\"):\n      context.modules[-1]+=value\n     else :\n      context.modules.append(value)\n     context.expect='.'\n   elif token ==\"OP\":\n    if context.expect ==\".\":\n     if value ==\".\":\n      context.modules[-1]+='.'\n     context.expect=\"module\"\n     \n     \nclass ModulesFinder:\n\n def __init__(self,directory=os.getcwd()):\n  self.directory=directory\n  self.modules=set()\n  \n def get_imports(self,src,package=None ):\n  ''\n  finder=ImportsFinder(package=package)\n  finder.find(src)\n  for module in finder.imports:\n   if module in self.modules:\n    continue\n   found=False\n   for module_dict in [stdlib,user_modules]:\n    if module in module_dict:\n     found=True\n     self.modules.add(module)\n     if module_dict[module][0]=='.py':\n      is_package=len(module_dict[module])==4\n      if is_package:\n       package=module\n      elif \".\"in module:\n       package=module[:module.rfind(\".\")]\n      else :\n       package=\"\"\n      module_dict[module][2]=list(self.get_imports(\n      module_dict[module][1],package))\n  return finder.imports\n  \n def norm_indent(self,script):\n  ''\n\n  \n  indent=None\n  lines=[]\n  for line in script.split('\\n'):\n   if line.strip()and indent is None :\n    indent=len(line)-len(line.lstrip())\n    line=line[indent:]\n   elif indent is not None :\n    line=line[indent:]\n   lines.append(line)\n  return '\\n'.join(lines)\n  \n def inspect(self):\n  ''\n\n  \n  site_packages='Lib{0}site-packages{0}'.format(os.sep)\n  imports=set()\n  for dirname,dirnames,filenames in os.walk(self.directory):\n   for name in dirnames:\n    if name.endswith('__dist__')or name.endswith(\"__pycache__\"):\n    \n     dirnames.remove(name)\n     break\n   for filename in filenames:\n    path=os.path.join(dirname,filename)\n    if path ==__file__:\n     continue\n    ext=os.path.splitext(filename)[1]\n    if ext.lower()=='.html':\n     print(\"script in html\",filename)\n     \n     charset_detector=CharsetDetector()\n     with open(path,encoding=\"iso-8859-1\")as fobj:\n      charset_detector.feed(fobj.read())\n      \n      \n     parser=BrythonScriptsExtractor(dirname)\n     with open(path,encoding=charset_detector.encoding)as fobj:\n      parser.feed(fobj.read())\n     for script in parser.scripts:\n      script=self.norm_indent(script)\n      try :\n       self.get_imports(script)\n      except SyntaxError:\n       print('syntax error',path)\n       traceback.print_exc(file=sys.stderr)\n    elif ext.lower()=='.py':\n    \n     if filename ==\"list_modules.py\":\n      continue\n     if dirname !=self.directory and not is_package(dirname):\n      continue\n      \n     package=dirname[len(self.directory)+1:]or None\n     if package is not None and\\\n     package.startswith(site_packages):\n      package=package[len('Lib/site-packages/'):]\n     with open(path,encoding=\"utf-8\")as fobj:\n      try :\n       imports |=self.get_imports(fobj.read(),package)\n      except SyntaxError:\n       print('syntax error',path)\n       traceback.print_exc(file=sys.stderr)\n       \n def make_brython_modules(self):\n  ''\n\n  \n  vfs={\"$timestamp\":int(1000 *time.time())}\n  for module in self.modules:\n   dico=stdlib if module in stdlib else user_modules\n   vfs[module]=dico[module]\n   elts=module.split('.')\n   for i in range(1,len(elts)):\n    pkg='.'.join(elts[:i])\n    if not pkg in vfs:\n     vfs[pkg]=dico[pkg]\n     \n  path=os.path.join(stdlib_dir,\"brython_modules.js\")\n  if os.path.exists(path):\n  \n  \n   changes=False\n   with open(path,encoding=\"utf-8\")as f:\n    content=f.read()\n    start_str=\"var scripts = \"\n    start_pos=content.find(start_str)\n    end_pos=content.find(\"__BRYTHON__.update_VFS(scripts)\")\n    data=content[start_pos+len(start_str):end_pos].strip()\n    old_vfs=json.loads(data)\n    if old_vfs.keys()!=vfs.keys():\n     changes=True\n    else :\n     changes=True\n     for key in old_vfs:\n      if key ==\"$timestamp\":\n       continue\n      if not key in vfs:\n       break\n      elif vfs[key][1]!=old_vfs[key][1]:\n       break\n     else :\n      changes=False\n      \n   if not changes:\n    print(\"No change: brython_modules.js not updated\")\n    return\n    \n  with open(path,\"w\",encoding=\"utf-8\")as out:\n  \n  \n   out.write(\"__BRYTHON__.VFS_timestamp = {}\\n\".format(\n   int(1000 *time.time())))\n   out.write(\"__BRYTHON__.use_VFS = true\\nvar scripts = \")\n   json.dump(vfs,out)\n   out.write(\"\\n__BRYTHON__.update_VFS(scripts)\")\n   \n   \n def _dest(self,base_dir,dirname,filename):\n  ''\n  elts=dirname[len(os.getcwd())+1:].split(os.sep)\n  dest_dir=base_dir\n  for elt in elts:\n   dest_dir=os.path.join(dest_dir,elt)\n   if not os.path.exists(dest_dir):\n    os.mkdir(dest_dir)\n  return os.path.join(dest_dir,filename)\n  \n def make_setup(self):\n  ''\n  \n  \n  temp_dir='__dist__'\n  if os.path.exists(temp_dir):\n   shutil.rmtree(temp_dir)\n  os.mkdir(temp_dir)\n  \n  \n  data_dir=os.path.join(temp_dir,'data')\n  os.mkdir(data_dir)\n  with open(os.path.join(data_dir,\"__init__.py\"),\"w\")as out:\n   out.write('')\n   \n   \n  if os.path.exists(\"brython_setup.json\"):\n   with open(\"brython_setup.json\",encoding=\"utf-8\")as fobj:\n    info=json.load(fobj)\n  else :\n  \n   while True :\n    app_name=input(\"Application name: \")\n    if app_name:\n     break\n   while True :\n    version=input(\"Version: \")\n    if version:\n     break\n   author=input(\"Author: \")\n   author_email=input(\"Author email: \")\n   license=input(\"License: \")\n   url=input(\"Project url: \")\n   info={\n   \"app_name\":app_name,\n   \"version\":version,\n   \"author\":author,\n   \"author_email\":author_email,\n   \"license\":license,\n   \"url\":url\n   }\n   \n   with open(\"brython_setup.json\",\"w\",encoding=\"utf-8\")as out:\n    json.dump(info,out,indent=4)\n    \n    \n    \n  files=[]\n  for dirname,dirnames,filenames in os.walk(self.directory):\n   if dirname ==\"__dist__\":\n    continue\n   if \"__dist__\"in dirnames:\n    dirnames.remove(\"__dist__\")\n   for filename in filenames:\n    path=os.path.join(dirname,filename)\n    parts=path[len(os.getcwd())+1:].split(os.sep)\n    files.append(\"os.path.join(\"+\n    \", \".join(repr(part)for part in parts)+\")\")\n    if os.path.splitext(filename)[1]=='.html':\n    \n     charset_detector=CharsetDetector()\n     with open(path,encoding=\"iso-8859-1\")as fobj:\n      charset_detector.feed(fobj.read())\n     encoding=charset_detector.encoding\n     \n     \n     parser=VFSReplacementParser(dirname)\n     with open(path,encoding=encoding)as fobj:\n      parser.feed(fobj.read())\n     if not parser.has_vfs:\n     \n      dest=self._dest(data_dir,dirname,filename)\n      shutil.copyfile(path,dest)\n      continue\n     with open(path,encoding=encoding)as fobj:\n      lines=fobj.readlines()\n      start_line,start_pos=parser.start\n      end_line,end_pos=parser.end\n      res=''.join(lines[:start_line -1])\n      for num in range(start_line -1,end_line):\n       res +=lines[num].replace(\"brython_stdlib.js\",\n       \"brython_modules.js\")\n      res +=''.join(lines[end_line:])\n     dest=self._dest(data_dir,dirname,filename)\n     with open(dest,'w',encoding=encoding)as out:\n      out.write(res)\n    else :\n     dest=self._dest(data_dir,dirname,filename)\n     shutil.copyfile(path,dest)\n     \n  info[\"files\"]=',\\n'.join(files)\n  \n  \n  path=os.path.join(temp_dir,\"setup.py\")\n  with open(path,\"w\",encoding=\"utf-8\")as out:\n   out.write(setup.format(**info))\n   \n   \n  path=os.path.join(temp_dir,\"{}.py\".format(info[\"app_name\"]))\n  with open(path,\"w\",encoding=\"utf-8\")as out:\n   out.write(app.format(**info))\n   \n   \nuser_modules={}\n\n\n\n\nprint('searching brython_stdlib.js...')\nstdlib={}\nstdlib_dir=None\nfor dirname,dirnames,filenames in os.walk(os.getcwd()):\n for filename in filenames:\n  if filename ==\"brython_stdlib.js\":\n   stdlib_dir=dirname\n   path=os.path.join(dirname,filename)\n   with open(path,encoding=\"utf-8\")as fobj:\n    modules=fobj.read()\n    modules=modules[modules.find('{'):\n    modules.find('__BRYTHON__.update_VFS(')]\n    stdlib=json.loads(modules)\n    \nif stdlib_dir is None :\n raise FileNotFoundError(\"Could not find brython_stdlib.js in this\"\n \" directory or below\")\nelse :\n\n sp_dir=os.path.join(stdlib_dir,\"Lib\",\"site-packages\")\n if os.path.exists(sp_dir):\n  print(\"search in site-packages...\")\n  mf=ModulesFinder()\n  for dirpath,dirnames,filenames in os.walk(sp_dir):\n   if dirpath.endswith(\"__pycache__\"):\n    continue\n   package=dirpath[len(sp_dir)+1:]\n   for filename in filenames:\n    if not filename.endswith(\".py\"):\n     continue\n    fullpath=os.path.join(dirpath,filename)\n    \n    is_package=False\n    if not package:\n    \n     module=os.path.splitext(filename)[0]\n    else :\n     elts=package.split(os.sep)\n     is_package=filename ==\"__init__.py\"\n     if not is_package:\n      elts.append(os.path.splitext(filename)[0])\n     module=\".\".join(elts)\n    with open(fullpath,encoding=\"utf-8\")as f:\n     src=f.read()\n     \n    stdlib[module]=[\".py\",src,None ]\n    if is_package:\n     stdlib[module].append(1)\n     \npackages={os.getcwd(),os.getcwd()+'/Lib/site-packages'}\n\ndef is_package(folder):\n ''\n\n\n \n if folder in packages:\n  return True\n current=folder\n while True :\n  if not os.path.exists(os.path.join(current,\"__init__.py\")):\n   return False\n  current=os.path.dirname(current)\n  if current in packages:\n   packages.add(folder)\n   return True\n   \nprint('finding packages...')\nfor dirname,dirnames,filenames in os.walk(os.getcwd()):\n for filename in filenames:\n  name,ext=os.path.splitext(filename)\n  if not ext ==\".py\"or filename ==\"list_modules.py\":\n   continue\n  if dirname ==os.getcwd():\n  \n   path=os.path.join(dirname,filename)\n   with open(path,encoding=\"utf-8\")as fobj:\n    src=fobj.read()\n   mf=ModulesFinder(dirname)\n   imports=sorted(list(mf.get_imports(src)))\n   user_modules[name]=[ext,src,imports]\n  elif is_package(dirname):\n  \n   path=os.path.join(dirname,filename)\n   package=dirname[len(os.getcwd())+1:].replace(os.sep,'.')\n   if package.startswith('Lib.site-packages.'):\n    package=package[len('Lib.site-packages.'):]\n   if filename ==\"__init__.py\":\n    module_name=package\n   else :\n    module_name=\"{}.{}\".format(package,name)\n   with open(path,encoding=\"utf-8\")as fobj:\n    src=fobj.read()\n    \n    \n    \n   user_modules[module_name]=[ext,src,None ]\n   if module_name ==package:\n    user_modules[module_name].append(1)\n    \n    \nclass CharsetDetector(html.parser.HTMLParser):\n ''\n \n def __init__(self,*args,**kw):\n  kw.setdefault('convert_charrefs',True )\n  try :\n   html.parser.HTMLParser.__init__(self,*args,**kw)\n  except TypeError:\n  \n   del kw['convert_charrefs']\n   html.parser.HTMLParser.__init__(self,*args,**kw)\n   \n  self.encoding=\"iso-8859-1\"\n  \n def handle_starttag(self,tag,attrs):\n  if tag.lower()==\"meta\":\n   for key,value in attrs:\n    if key ==\"charset\":\n     self.encoding=value\n     \nclass BrythonScriptsExtractor(html.parser.HTMLParser):\n ''\n \n def __init__(self,dirname,**kw):\n  kw.setdefault('convert_charrefs',True )\n  try :\n   html.parser.HTMLParser.__init__(self,**kw)\n  except TypeError:\n  \n   del kw['convert_charrefs']\n   html.parser.HTMLParser.__init__(self,**kw)\n   \n  self.dirname=dirname\n  self.scripts=[]\n  self.py_tags=[]\n  self.tag_stack=[]\n  \n def handle_starttag(self,tag,attrs):\n  if tag.lower()==\"script\":\n   _type=\"js_script\"\n   src=None\n   for key,value in attrs:\n    if key =='type'and value in (\"text/python\",\"text/python3\"):\n     _type=\"py_script\"\n    elif key ==\"src\":\n     src=value\n   if _type ==\"py_script\"and src:\n    _type=\"py_script_with_src\"\n    path=os.path.join(self.dirname,src)\n    with open(path,encoding=\"utf-8\")as fobj:\n     self.scripts.append(fobj.read())\n   self.tag_stack.append(_type)\n   \n def handle_endtag(self,tag):\n  if tag.lower()==\"script\":\n   self.tag_stack.pop()\n   \n def handle_data(self,data):\n  ''\n  if data.strip():\n   if self.tag_stack and self.tag_stack[-1].lower()==\"py_script\":\n    self.scripts.append(data)\n    \n    \nclass VFSReplacementParser(html.parser.HTMLParser):\n ''\n \n \n def __init__(self,path,**kw):\n  kw.setdefault('convert_charrefs',True )\n  try :\n   html.parser.HTMLParser.__init__(self,**kw)\n  except TypeError:\n  \n   del kw['convert_charrefs']\n   html.parser.HTMLParser.__init__(self,**kw)\n  self.vfs=False\n  self.has_vfs=False\n  \n def handle_starttag(self,tag,attrs):\n  if tag.lower()==\"script\":\n   _type=\"js_script\"\n   src=None\n   for key,value in attrs:\n    if key ==\"src\":\n     elts=value.split(\"/\")\n     if elts and elts[-1]==\"brython_stdlib.js\":\n      self.vfs=True\n      self.has_vfs=True\n      self.attrs=attrs\n      self.start=self.getpos()\n      return\n  self.vfs=False\n  \n def handle_endtag(self,tag):\n  if tag.lower()==\"script\"and self.vfs:\n   self.end=self.getpos()\n   \n   \nif __name__ ==\"__main__\":\n finder=ModulesFinder()\n finder.inspect()\n print(sorted(list(finder.modules)))\n \n", ["html.parser", "io", "json", "os", "shutil", "sys", "time", "token", "tokenize", "traceback"]], "brython.make_file_system": [".py", "import json\nimport os\nimport stat\nimport sys\nimport binascii\n\ndef make(vfs_name,prefix=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n files={}\n \n this_dir=os.getcwd()\n dest_file=f\"{vfs_name}.vfs.js\"\n virtual_dir=prefix.split(\"/\")if prefix else []\n print(\"virtual dir\",virtual_dir)\n \n for dirpath,dirnames,filenames in os.walk(this_dir):\n  if dirpath ==this_dir:\n   path=[]\n  else :\n   path=dirpath[len(this_dir)+len(os.sep):].split(os.sep)\n  for filename in filenames:\n   if filename.endswith(\".vfs.js\"):\n    continue\n   rel_path=\"/\".join(virtual_dir+path+[filename])\n   with open(os.path.join(dirpath,filename),\"rb\")as f:\n   \n    content=binascii.b2a_base64(f.read()).decode('ascii')\n    file_stat=os.fstat(f.fileno())\n    files[rel_path]={\n    \"content\":content,\n    \"ctime\":file_stat.st_ctime,\n    \"mtime\":file_stat.st_mtime\n    }\n    \n print(list(files))\n with open(dest_file,\"w\",encoding=\"utf-8\")as out:\n  out.write(\"__BRYTHON__.add_files(\")\n  json.dump(files,out,indent=4)\n  out.write(\")\")\n", ["binascii", "json", "os", "stat", "sys"]], "brython.make_package": [".py", "import json\nimport os\nimport re\nimport time\nimport ast\n\nfrom . import python_minifier\n\nclass Visitor(ast.NodeVisitor):\n ''\n \n def __init__(self,lib_path,package):\n  self.imports=set()\n  self.lib_path=lib_path\n  self.package=package\n  \n def visit_Import(self,node):\n  for alias in node.names:\n   self.imports.add(alias.name)\n   \n def visit_ImportFrom(self,node):\n  if node.level >0:\n   package=self.package[:]\n   level=node.level -1\n   while level:\n    package.pop()\n    level -=1\n   module=\".\".join(package)\n   if node.module:\n    module +=\".\"+node.module\n  else :\n   module=node.module\n  self.imports.add(module)\n  for alias in node.names:\n   if alias.name ==\"*\":\n    continue\n   else :\n   \n   \n    path=os.path.join(self.lib_path,*module.split(\".\"),\n    alias.name+\".py\")\n    if os.path.exists(path):\n     self.imports.add(module+\".\"+alias.name)\n     \n     \ndef make(package_name,package_path,exclude_dirs=None ):\n if not package_name:\n  raise ValueError(\"package name is not specified\")\n print(\"Generating package {}\".format(package_name))\n VFS={\"$timestamp\":int(1000 *time.time())}\n has_init=os.path.exists(os.path.join(package_path,\"__init__.py\"))\n nb=0\n if exclude_dirs is None :\n  exclude_dirs=[]\n for dirpath,dirnames,filenames in os.walk(package_path):\n  flag=False\n  root_elts=dirpath.split(os.sep)\n  for exclude in exclude_dirs:\n   if exclude in root_elts:\n    continue\n  if '__pycache__'in dirnames:\n   dirnames.remove(\"__pycache__\")\n   \n  if dirpath ==package_path:\n   package=[]\n  else :\n   package=dirpath[len(package_path)+1:].split(os.sep)\n  if has_init:\n   package.insert(0,package_name)\n   \n  for filename in filenames:\n   name,ext=os.path.splitext(filename)\n   if ext !='.py':\n    continue\n   is_package=name.endswith('__init__')\n   if is_package:\n    mod_name='.'.join(package)\n   else :\n    mod_name='.'.join(package+[name])\n    \n   nb +=1\n   absname=os.path.join(dirpath,filename)\n   with open(absname,encoding='utf-8')as f:\n    data=f.read()\n    \n   data=python_minifier.minify(data,preserve_lines=True )\n   path_elts=package[:]\n   if os.path.basename(filename)!=\"__init__.py\":\n    path_elts.append(os.path.basename(filename)[:-3])\n   fqname=\".\".join(path_elts)\n   with open(absname,encoding=\"utf-8\")as f:\n    tree=ast.parse(f.read())\n    visitor=Visitor(package_path,package)\n    visitor.visit(tree)\n    imports=sorted(list(visitor.imports))\n    \n   if is_package:\n    VFS[mod_name]=[ext,data,imports,1]\n   else :\n    VFS[mod_name]=[ext,data,imports]\n    \n   print(\"adding {} package {}\".format(mod_name,is_package))\n   \n if nb ==0:\n  print(\"No Python file found in current directory\")\n else :\n  print('{} files'.format(nb))\n  with open(os.path.join(package_path,package_name+\".brython.js\"),\n  \"w\",encoding=\"utf-8\")as out:\n   out.write('__BRYTHON__.use_VFS = true;\\n')\n   out.write('var scripts = {}\\n'.format(json.dumps(VFS)))\n   out.write('__BRYTHON__.update_VFS(scripts)\\n')\n   \nif __name__ ==\"__main__\":\n import sys\n package_name=sys.argv[1]if len(sys.argv)>1 else \"\"\n src_dir=sys.argv[2]if len(sys.argv)>2 else os.getcwd()\n \n make(package_name,src_dir)\n", ["ast", "brython", "brython.python_minifier", "json", "os", "re", "sys", "time"]], "brython.python_minifier": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport os\nimport token\nimport tokenize\nimport re\nimport io\nfrom keyword import kwlist\n\nfor kw in [\"async\",\"await\"]:\n if kw not in kwlist:\n  kwlist.append(kw)\n  \nasync_types=[]\nif hasattr(tokenize,\"ASYNC\"):\n async_types.append(tokenize.ASYNC)\nif hasattr(tokenize,\"AWAIT\"):\n async_types.append(tokenize.AWAIT)\n \ndef minify(src,preserve_lines=False ):\n\n\n file_obj=io.BytesIO(src.encode('utf-8'))\n token_generator=tokenize.tokenize(file_obj.readline)\n \n out=''\n line=0\n last_item=None\n last_type=None\n indent=0\n brackets=[]\n orig_lines=src.split(\"\\n\")\n \n \n encoding=next(token_generator).string\n \n file_obj=io.BytesIO(src.encode(encoding))\n token_generator=tokenize.tokenize(file_obj.readline)\n \n for item in token_generator:\n \n  if token.tok_name[item.type]=='OP':\n   if item.string in '([{':\n    brackets.append(item.string)\n   elif item.string in '}])':\n    brackets.pop()\n    \n  sline=item.start[0]\n  if sline ==0:\n   continue\n   \n   \n  if item.type ==tokenize.INDENT:\n   indent +=1\n  elif item.type ==tokenize.DEDENT:\n   indent -=1\n   continue\n   \n  if sline >line:\n  \n   while out.count(\"\\n\")<sline -1:\n    if last_item.line.rstrip().endswith(\"\\\\\"):\n     out +=\"\\\\\"\n    out +=\"\\n\"\n    \n   if not brackets and item.type ==tokenize.STRING:\n    if last_type in [tokenize.NEWLINE,tokenize.INDENT,None ]:\n    \n    \n    \n    \n     out +=' '*indent+\"''\"\n     if preserve_lines:\n      out +='\\n'*item.string.count('\\n')\n     continue\n   out +=' '*indent\n   if item.type not in [tokenize.INDENT,tokenize.COMMENT]:\n    out +=item.string\n   elif (item.type ==tokenize.COMMENT and\n   line <=2 and item.line.startswith('#!')):\n   \n   \n    out +=item.string\n  else :\n   if item.type ==tokenize.COMMENT:\n    continue\n   if (not brackets and item.type ==tokenize.STRING and\n   last_type in [tokenize.NEWLINE,tokenize.INDENT]):\n   \n   \n    out +=\"''\"\n    if preserve_lines:\n     out +='\\n'*item.string.count('\\n')\n    continue\n   previous_types=[tokenize.NAME,tokenize.NUMBER]+async_types\n   if item.type in [tokenize.NAME,tokenize.NUMBER,tokenize.OP]and\\\n   last_type in previous_types:\n   \n    if (item.type !=tokenize.OP\\\n    or item.string not in ',()[].=:{}+&'\\\n    or (last_type ==tokenize.NAME and\n    last_item.string in kwlist)):\n     out +=' '\n   elif (item.type ==tokenize.STRING and\n   last_type in [tokenize.NAME,tokenize.NUMBER]):\n   \n    out +=' '\n   elif (item.type ==tokenize.NAME and\n   item.string ==\"import\"and\n   last_item.type ==tokenize.OP and\n   last_item.string =='.'):\n   \n    out +=' '\n   elif (item.type in async_types and\n   last_item.type in previous_types):\n    out +=' '\n   out +=item.string\n   \n  line=item.end[0]\n  last_item=item\n  if item.type ==tokenize.NL and last_type ==tokenize.COMMENT:\n  \n   last_type=tokenize.NEWLINE\n  else :\n   last_type=item.type\n   \n   \n out=re.sub(r'^\\s+$','',out,re.M)\n \n if not preserve_lines:\n \n  out=re.sub(\"^''\\n\",'',out)\n  \n  \n  out=re.sub('\\n( *\\n)+','\\n',out)\n  \n  \n  \n  def repl(mo):\n   if mo.groups()[0]==mo.groups()[1]:\n    return '\\n'+mo.groups()[1]\n   return mo.string[mo.start():mo.end()]\n  out=re.sub(\"\\n( *)''\\n( *)\",repl,out)\n  \n return out\n", ["io", "keyword", "os", "re", "token", "tokenize"]], "brython": [".py", "__version__=implementation=\"3.9.0\"\n", [], 1], "brython.__main__": [".py", "''\n\n\n\nimport os\nimport shutil\nimport json\nimport argparse\n\nfrom . import implementation\n\ndef main():\n parser=argparse.ArgumentParser()\n \n parser.add_argument('--add_package',\n help=\"Add a CPython package in Lib/site-packages\")\n \n parser.add_argument('--install',help='Install Brython in an empty directory',\n action=\"store_true\")\n \n parser.add_argument('--make_dist',help='Make a Python distribution',\n action=\"store_true\")\n \n parser.add_argument('--make_package',help='Make a loadable Python package')\n \n parser.add_argument('--make_file_system',help='Make a virtual file system')\n \n parser.add_argument('--modules',\n help='Create brython_modules.js with all the modules used by the application',\n action=\"store_true\")\n \n parser.add_argument('--reset',help='Reset brython_modules.js to stdlib',\n action=\"store_true\")\n \n parser.add_argument('--server',help='Start development server',nargs=\"?\",\n default=\"absent\")\n \n parser.add_argument('--update',help='Update Brython scripts',\n action=\"store_true\")\n \n args=parser.parse_args()\n \n files=['README.txt','demo.html','index.html',\n 'brython.js','brython_stdlib.js','unicode.txt']\n \n if args.add_package:\n  print('add package {}...'.format(args.add_package))\n  package=__import__(args.add_package)\n  package_file=package.__file__\n  package_dir=os.path.dirname(package_file)\n  lib_dir=os.path.join(os.getcwd(),'Lib')\n  if not os.path.exists(lib_dir):\n   os.mkdir(lib_dir)\n  dest_dir=os.path.join(lib_dir,'site-packages')\n  if not os.path.exists(dest_dir):\n   os.mkdir(dest_dir)\n   \n  if os.path.splitext(package_dir)[1]=='.egg':\n   import zipfile\n   zf=zipfile.ZipFile(package_dir)\n   for info in zf.infolist():\n    if info.filename.startswith(('__pycache__','EGG-INFO')):\n     continue\n    zf.extract(info,dest_dir)\n    print('extract',info.filename)\n   zf.close()\n   print('done')\n  elif not package_dir.split(os.sep)[-1]==\"site-packages\":\n   print('copy folder',package_dir)\n   dest_dir=os.path.join(dest_dir,args.add_package)\n   if os.path.exists(dest_dir):\n    shutil.rmtree(dest_dir)\n   shutil.copytree(package_dir,dest_dir)\n  else :\n   print('copy single file',package_file)\n   shutil.copyfile(package_file,os.path.join(dest_dir,\n   os.path.basename(package_file)))\n   \n if args.install:\n  print('Installing Brython {}'.format(implementation))\n  \n  data_path=os.path.join(os.path.dirname(__file__),'data')\n  current_path_files=os.listdir(os.getcwd())\n  \n  if current_path_files and 'brython.js'in current_path_files:\n   override=input(\n   'brython.js is already present in this directory.'\n   ' Override ? (Y/N)'\n   )\n   if override.lower()!='y':\n    import sys\n    print('exiting')\n    sys.exit()\n    \n  for path in os.listdir(data_path):\n   try :\n    shutil.copyfile(os.path.join(data_path,path),path)\n   except shutil.SameFileError:\n    print(f'{path} has not been moved. Are the same file.')\n    \n  print('done')\n  \n if args.update:\n  print('Update Brython scripts to version {}'.format(implementation))\n  \n  data_path=os.path.join(os.path.dirname(__file__),'data')\n  \n  for path in os.listdir(data_path):\n   shutil.copyfile(os.path.join(data_path,path),path)\n   \n if args.reset:\n  print('Reset brython_modules.js to standard distribution')\n  shutil.copyfile(os.path.join(os.getcwd(),'brython_stdlib.js'),\n  os.path.join(os.getcwd(),'brython_modules.js'))\n  \n if args.modules:\n  print('Create brython_modules.js with all the modules used by the '\n  'application')\n  from . import list_modules\n  \n  finder=list_modules.ModulesFinder()\n  finder.inspect()\n  finder.make_brython_modules()\n  \n if args.make_dist:\n  print('Make a Python distribution for the application')\n  from . import list_modules\n  finder=list_modules.ModulesFinder()\n  finder.inspect()\n  finder.make_brython_modules()\n  finder.make_setup()\n  print('done')\n  \n if args.make_file_system:\n  print('Create a Javascript file for all the files in the directory')\n  args_fs=args.make_file_system.split(\"#\")\n  if len(args_fs)>2:\n   raise ValueError(\"--make_file_systems expects at most 2 \"\n   \"arguments, got \"+str(len(args_fs)))\n  vfs_name=args_fs[0]\n  prefix=args_fs[1]if len(args_fs)>1 else None\n  from .make_file_system import make\n  make(vfs_name,prefix)\n  print('done')\n  \n if args.make_package:\n  package_name=args.make_package\n  from . import make_package\n  make_package.make(package_name,os.getcwd())\n  print(\"done\")\n  \n if args.server !=\"absent\":\n \n  import http.server\n  import sysconfig\n  cpython_site_packages=sysconfig.get_path(\"purelib\")\n  \n  class Handler(http.server.CGIHTTPRequestHandler):\n  \n   def guess_type(self,path):\n    ctype=super().guess_type(path)\n    \n    \n    if os.path.splitext(path)[1]==\".js\":\n     ctype=\"application/javascript\"\n    return ctype\n    \n   def translate_path(self,path):\n    ''\n    \n    elts=path.split('/')\n    if len(elts)>1 and elts[0]=='':\n     if elts[1]=='cpython_site_packages':\n      elts[-1]=elts[-1].split(\"?\")[0]\n      return os.path.join(cpython_site_packages,*elts[2:])\n    return super().translate_path(path)\n    \n    \n    \n  port=8000 if args.server is None else int(args.server)\n  \n  print(\"Brython development server. \"\n  \"Not meant to be used in production.\")\n  if args.server is None :\n   print(\"For a different port provide command-line option \"\n   '\"--server PORT\".')\n  print(\"Press CTRL+C to Quit.\\n\")\n  http.server.test(HandlerClass=Handler,port=port)\n  \nif __name__ ==\"__main__\":\n main()\n", ["argparse", "brython", "brython.list_modules", "brython.make_file_system", "brython.make_package", "http.server", "json", "os", "shutil", "sys", "sysconfig", "zipfile"]]}
__BRYTHON__.update_VFS(scripts)
